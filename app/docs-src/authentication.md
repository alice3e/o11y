# Аутентификация и взаимодействие между сервисами

В нашей микросервисной архитектуре реализована надежная система аутентификации и авторизации, обеспечивающая безопасное взаимодействие как между пользователем и сервисами, так и между самими сервисами.

## JWT-аутентификация

Основной механизм аутентификации в системе - JSON Web Tokens (JWT). Этот подход имеет следующие преимущества:

1. **Безопасность**: Токены подписываются секретным ключом, что гарантирует их подлинность
2. **Отсутствие состояния**: Серверу не нужно хранить сессии пользователей
3. **Масштабируемость**: Подходит для микросервисной архитектуры
4. **Передача данных**: Токен содержит информацию о пользователе (username)

## Процесс аутентификации

1. **Регистрация пользователя**:
   - Пользователь регистрируется через User Service (`POST /user-api/users/register`)
   - Пароль хешируется и сохраняется в базе данных
   - Возвращается информация о созданном пользователе

2. **Получение токена**:
   - Пользователь отправляет логин и пароль на эндпоинт `/user-api/token`
   - User Service проверяет учетные данные
   - При успешной аутентификации генерируется JWT токен с именем пользователя в поле "sub"
   - Токен возвращается клиенту

3. **Использование токена**:
   - Клиент включает токен в заголовок `Authorization` при каждом запросе
   - Формат: `Authorization: Bearer <jwt_token>`
   - Сервисы проверяют токен и извлекают имя пользователя для идентификации

## Демо-пользователи для тестирования

Для удобства тестирования API, при запуске сервиса пользователей автоматически создаются два демо-пользователя:

1. **swagger_admin**:
   - Пользователь с административными правами
   - Логин: `swagger_admin`
   - Пароль: `admin123`
   - Используется для доступа к эндпоинтам, требующим прав администратора

2. **swagger_user**:
   - Обычный пользователь без административных прав
   - Логин: `swagger_user`
   - Пароль: `password123`
   - Используется для тестирования обычных пользовательских сценариев

Учетные данные этих пользователей и их токены выводятся в логи контейнера при запуске сервиса.

## Аутоматическая аутентификация в Swagger UI

Для упрощения тестирования API, Swagger UI настроен на автоматическую аутентификацию:

1. **Автоматический вход**:
   - При открытии [Swagger UI](http://localhost/swagger/) автоматически выполняется вход под пользователем `swagger_admin`
   - Токен получается через специальный эндпоинт `/user-api/swagger-admin-token`
   - Административный режим включается автоматически

2. **Смена пользователя**:
   - Вы можете получить новый токен через эндпоинт `POST /user-api/token` с другими учетными данными
   - Вставьте новый токен в поле "JWT Token" в верхней части страницы
   - Нажмите кнопку "Authorize"
   - Настройте режим администратора с помощью флажка "Admin Mode"

3. **Визуальная индикация**:
   - В верхней части страницы отображается имя текущего пользователя
   - Флажок "Admin Mode" показывает, активен ли режим администратора

## Межсервисное взаимодействие

Для обеспечения безопасного взаимодействия между микросервисами реализованы следующие механизмы:

### 1. Передача JWT токена

При взаимодействии между сервисами JWT токен передается в заголовке `Authorization`. Например, когда Cart Service вызывает Order Service для создания заказа:

```python
# Пример из Cart Service
headers = {}
if authorization:  # Если токен был получен от клиента
    headers["Authorization"] = authorization

# Вызов Order Service с передачей токена
async with httpx.AsyncClient() as client:
    response = await client.post(
        f"{ORDER_SERVICE_URL}/orders/",
        json=order_data,
        headers=headers
    )
```

### 2. Использование заголовка X-User-ID

Для обеспечения совместимости и дополнительной идентификации используется заголовок `X-User-ID`, который содержит имя пользователя:

```python
# Пример из Cart Service
headers = {
    "X-User-ID": user_id
}
if authorization:
    headers["Authorization"] = authorization

# Вызов Order Service с передачей обоих заголовков
```

### 3. Извлечение пользователя из токена

Все сервисы (Cart Service, Order Service) используют одинаковую логику для извлечения имени пользователя из JWT токена:

```python
# Пример из Order Service и Cart Service
async def get_user_id(
    authorization: Optional[str] = Header(None), 
    x_user_id: Optional[str] = Header(None)
) -> str:
    """Получение идентификатора пользователя из заголовка Authorization или X-User-ID"""
    if x_user_id:
        return x_user_id
    
    if not authorization:
        raise HTTPException(status_code=401, detail="Authorization header missing")
    
    # Извлекаем user_id из токена
    parts = authorization.split()
    if len(parts) != 2 or parts[0].lower() != "bearer":
        raise HTTPException(status_code=401, detail="Invalid authorization header")
    
    token = parts[1]
    
    # Пытаемся декодировать JWT для получения username
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username:
            return username
    except JWTError:
        # Если не удалось декодировать, используем токен как идентификатор
        pass
    
    # Возвращаем токен как идентификатор пользователя (fallback)
    return token
```

## Обработка ошибок аутентификации

Система обрабатывает различные сценарии ошибок аутентификации:

1. **Отсутствие токена**: Возвращается ошибка 401 Unauthorized
2. **Недействительный токен**: Возвращается ошибка 401 Unauthorized с деталями
3. **Истекший токен**: Пользователю необходимо получить новый токен
4. **Недостаточные права**: Возвращается ошибка 403 Forbidden

## Конфигурация аутентификации

Система аутентификации использует следующие переменные окружения:

### Переменные окружения

- **SECRET_KEY**: Секретный ключ для подписи JWT токенов
  - Значение по умолчанию: `supersecretkey123`
  - Используется всеми сервисами (User, Cart, Order)
  - В docker-compose.yml настроен одинаковый ключ для всех сервисов

- **ALGORITHM**: Алгоритм подписи JWT токенов
  - Значение по умолчанию: `HS256`
  - Стандартный алгоритм для HMAC с SHA-256

Пример конфигурации в docker-compose.yml:
```yaml
environment:
  - SECRET_KEY=supersecretkey123
```

## Рекомендации по безопасности

1. **Защита секретного ключа**: Секретный ключ для подписи JWT должен храниться в безопасном месте
2. **Короткий срок действия токенов**: Рекомендуется устанавливать небольшой срок действия токенов
3. **HTTPS**: Все взаимодействия должны происходить по защищенному протоколу HTTPS
4. **Валидация данных**: Все входные данные должны проходить валидацию

## Тестирование аутентификации

Для тестирования механизма аутентификации можно использовать скрипт `test_all_microservices.sh`, который демонстрирует полный процесс регистрации, получения токена и его использования для доступа к защищенным ресурсам.

Пример запуска:

```bash
./test_all_microservices.sh
```

Этот скрипт выполняет следующие действия:
1. Регистрирует нового пользователя
2. Получает JWT токен
3. Использует токен для доступа к защищенным эндпоинтам
4. Демонстрирует взаимодействие между сервисами с передачей токена 